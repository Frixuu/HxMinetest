// SPDX-License-Identifier: Zlib
// deno-lint-ignore-file no-explicit-any

import { path, xml } from "./deps.ts";
import { abort, assertHaxeExists, decodeUtf8, encodeUtf8, invokeHaxe, mustArray, pathFromMeta } from "./common.ts";
import { Class, Interface, Path, Type } from "./haxe/types.ts";
import { Context } from "./haxe/documentation/context.ts";
import { renderClass } from "./haxe/documentation/render.ts";

await assertHaxeExists();

// First, dump the compiler output to an XML file
const { success, stderr } = await invokeHaxe({
  classpaths: ["src"],
  libraries: ["partials"],
  initMacros: ["include('doctest')", "include('minetest')"],
  other: ["--lua", "not.applicable", "--no-output", "--xml", "docs/reference/classes.xml"]
});

if (!success) {
  abort(`Generating XML failed: ${decodeUtf8(stderr)}`);
}

// Then, try to read all the classes
const root = path.join(pathFromMeta(import.meta), "..", "..");
const docRoot = path.join(root, "docs");
const referenceRoot = path.join(docRoot, "reference");
const xmlPath = path.join(referenceRoot, "classes.xml");
const documentString = decodeUtf8(await Deno.readFile(xmlPath));
const document = xml.parse(documentString)["haxe"]! as any;


const context = new Context();

for (const clazz of document["class"]) {

  const discriminator = clazz["@interface"] ? "interface" : "class";
  const path = Path.fromDotPath(clazz["@path"]);
  const isPrivate = clazz["@private"] !== undefined;
  const isExtern = clazz["@extern"] !== undefined;
  const isFinal = clazz["@final"] !== undefined;
  const isAbstract = clazz["@abstract"] !== undefined;
  const interfacePaths = mustArray(clazz["implements"]).map(i => Path.fromDotPath(i["@path"] ?? ""));

  const superClass = clazz["extends"]?.["@path"];

  if (discriminator == "class") {
    context.registerClass({
      discriminator, path, isPrivate, isExtern, isFinal, isAbstract, interfacePaths,
      superClassPath: superClass ? Path.fromDotPath(superClass) : undefined,
    });
  } else {
    context.registerInterface({
      discriminator, path, isPrivate, isExtern, isFinal, interfacePaths
    });
  }
}

// Render to Markdown
try {
  await Deno.remove(path.join(referenceRoot, "minetest"), { recursive: true });
} catch (e) {
  if (!(e instanceof Deno.errors.NotFound)) {
    throw e;
  }
}

const visitedTypes: Type[] = [];

for (const clazz of context.getClasses(["minetest"])) {
  visitedTypes.push(clazz);
  const packDir = path.join(referenceRoot, ...clazz.path.pack);
  await Deno.mkdir(packDir, { recursive: true });
  const markdown = renderClass(context, clazz);
  await Deno.writeFile(path.join(packDir, `${clazz.path.shortName()}.md`), encodeUtf8(markdown));
}

// Generate sidebar

interface PathItem {
  pathSoFar: string[];
  childPackages: Map<string, PathItem>;
  types: Type[];
}

const sidebarRoot: PathItem = {
  pathSoFar: [],
  childPackages: new Map(),
  types: [],
}

for (const typ of visitedTypes) {
  let root = sidebarRoot;
  let packRemaining = typ.path.pack;
  const pathSoFar = [];
  while (packRemaining.length > 0) {
    const first = packRemaining[0];
    pathSoFar.push(first);
    packRemaining = packRemaining.slice(1);
    let child = root.childPackages.get(first);
    if (child === undefined) {
      child = { pathSoFar, childPackages: new Map(), types: [] };
      root.childPackages.set(first, child);
    }
    root = child;
  }
  root.types.push(typ);
}

function generateType(type: Type): { text: string, link: string } {
  return {
    text: type.path.shortName(),
    link: `/${path.join("reference", ...type.path.pack, type.path.shortName())}`
  };
}


function generateItems(el: PathItem): any[] {
  const children = Array.from(el.childPackages.values()).map(p => generatePathItem(p));
  const types = el.types.map(t => generateType(t));
  return children.concat(types);
}

function generatePathItem(el: PathItem): any {
  return {
    text: el.pathSoFar[el.pathSoFar.length - 1],
    collapsed: true,
    items: generateItems(el),
  };
}


let sidebarText = "export default ";
sidebarText += JSON.stringify(generateItems(sidebarRoot));
sidebarText += ";\n";
await Deno.writeFile(path.join(docRoot, ".vitepress", "reference-sidebar.autogenerated.ts"), encodeUtf8(sidebarText));
